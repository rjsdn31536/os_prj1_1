!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CLS_CODE_DATA	gdt.c	/^    CLS_CODE_DATA = 1           \/* Code or data segment. *\/$/;"	e	enum:seg_class	file:
CLS_SYSTEM	gdt.c	/^    CLS_SYSTEM = 0,             \/* System segment. *\/$/;"	e	enum:seg_class	file:
DEPENDS	build/Makefile	/^DEPENDS = $(patsubst %.o,%.d,$(OBJECTS))$/;"	m
Elf32_Addr	process.c	/^typedef uint32_t Elf32_Word, Elf32_Addr, Elf32_Off;$/;"	t	file:
Elf32_Ehdr	process.c	/^struct Elf32_Ehdr$/;"	s	file:
Elf32_Half	process.c	/^typedef uint16_t Elf32_Half;$/;"	t	file:
Elf32_Off	process.c	/^typedef uint32_t Elf32_Word, Elf32_Addr, Elf32_Off;$/;"	t	file:
Elf32_Phdr	process.c	/^struct Elf32_Phdr$/;"	s	file:
Elf32_Word	process.c	/^typedef uint32_t Elf32_Word, Elf32_Addr, Elf32_Off;$/;"	t	file:
GRAN_BYTE	gdt.c	/^    GRAN_BYTE = 0,              \/* Limit has 1-byte granularity. *\/$/;"	e	enum:seg_granularity	file:
GRAN_PAGE	gdt.c	/^    GRAN_PAGE = 1               \/* Limit has 4 kB granularity. *\/$/;"	e	enum:seg_granularity	file:
NO_RETURN	process.c	/^static thread_func start_process NO_RETURN;$/;"	v	file:
OBJECTS	build/Makefile	/^OBJECTS = $(patsubst %.c,%.o,$(patsubst %.S,%.o,$(SOURCES)))$/;"	m
PE32Ax	process.c	184;"	d	file:
PE32Hx	process.c	186;"	d	file:
PE32Ox	process.c	185;"	d	file:
PE32Wx	process.c	183;"	d	file:
PF_P	exception.h	5;"	d
PF_R	process.c	236;"	d	file:
PF_U	exception.h	7;"	d
PF_W	exception.h	6;"	d
PF_W	process.c	235;"	d	file:
PF_X	process.c	234;"	d	file:
PHYS_BASE	exception.c	8;"	d	file:
PT_DYNAMIC	process.c	226;"	d	file:
PT_INTERP	process.c	227;"	d	file:
PT_LOAD	process.c	225;"	d	file:
PT_NOTE	process.c	228;"	d	file:
PT_NULL	process.c	224;"	d	file:
PT_PHDR	process.c	230;"	d	file:
PT_SHLIB	process.c	229;"	d	file:
PT_STACK	process.c	231;"	d	file:
SEL_CNT	gdt.h	11;"	d
SEL_TSS	gdt.h	10;"	d
SEL_UCSEG	gdt.h	8;"	d
SEL_UDSEG	gdt.h	9;"	d
SOURCES	build/Makefile	/^SOURCES = $(foreach dir,$(KERNEL_SUBDIRS),$($(dir)_SRC))$/;"	m
SRCDIR	build/Makefile	/^SRCDIR = ..\/..$/;"	m
USERPROG_EXCEPTION_H	exception.h	2;"	d
USERPROG_GDT_H	gdt.h	2;"	d
USERPROG_PAGEDIR_H	pagedir.h	2;"	d
USERPROG_PROCESS_H	process.h	2;"	d
USERPROG_SYSCALL_H	syscall.h	2;"	d
USERPROG_TSS_H	tss.h	2;"	d
_end	build/threads/kernel.lds.s	/^  _end = .;$/;"	d
_end_bss	build/threads/kernel.lds.s	/^  _end_bss = .;$/;"	d
_end_kernel_text	build/threads/kernel.lds.s	/^       _end_kernel_text = .; }$/;"	d
_signature	build/threads/kernel.lds.s	/^     _signature = .; LONG(0xaa55aa55) }$/;"	d
_start	build/threads/kernel.lds.s	/^  _start = 0xc0000000 + 0x20000;$/;"	d
_start_bss	build/threads/kernel.lds.s	/^  _start_bss = .;$/;"	d
active_pd	pagedir.c	/^active_pd (void) $/;"	f	file:
back_link	tss.c	/^    uint16_t back_link, :16;$/;"	m	struct:tss	file:
bitmap	tss.c	/^    uint16_t trace, bitmap;$/;"	m	struct:tss	file:
check_vaddr	syscall.c	/^void check_vaddr(const void *vaddr){$/;"	f
close	syscall.c	/^void close(int fd)$/;"	f
cr3	tss.c	/^    uint32_t cr3;$/;"	m	struct:tss	file:
create	syscall.c	/^bool create ( const char *file, unsigned initial_size)$/;"	f
cs	tss.c	/^    uint16_t cs, :16;$/;"	m	struct:tss	file:
deny_write	syscall.h	/^	bool deny_write;$/;"	m	struct:file
devices_SRC	build/Makefile	/^devices_SRC  = devices\/pit.c		# Programmable interrupt timer chip.$/;"	m
ds	tss.c	/^    uint16_t ds, :16;$/;"	m	struct:tss	file:
e_ehsize	process.c	/^    Elf32_Half    e_ehsize;$/;"	m	struct:Elf32_Ehdr	file:
e_entry	process.c	/^    Elf32_Addr    e_entry;$/;"	m	struct:Elf32_Ehdr	file:
e_flags	process.c	/^    Elf32_Word    e_flags;$/;"	m	struct:Elf32_Ehdr	file:
e_ident	process.c	/^    unsigned char e_ident[16];$/;"	m	struct:Elf32_Ehdr	file:
e_machine	process.c	/^    Elf32_Half    e_machine;$/;"	m	struct:Elf32_Ehdr	file:
e_phentsize	process.c	/^    Elf32_Half    e_phentsize;$/;"	m	struct:Elf32_Ehdr	file:
e_phnum	process.c	/^    Elf32_Half    e_phnum;$/;"	m	struct:Elf32_Ehdr	file:
e_phoff	process.c	/^    Elf32_Off     e_phoff;$/;"	m	struct:Elf32_Ehdr	file:
e_shentsize	process.c	/^    Elf32_Half    e_shentsize;$/;"	m	struct:Elf32_Ehdr	file:
e_shnum	process.c	/^    Elf32_Half    e_shnum;$/;"	m	struct:Elf32_Ehdr	file:
e_shoff	process.c	/^    Elf32_Off     e_shoff;$/;"	m	struct:Elf32_Ehdr	file:
e_shstrndx	process.c	/^    Elf32_Half    e_shstrndx;$/;"	m	struct:Elf32_Ehdr	file:
e_type	process.c	/^    Elf32_Half    e_type;$/;"	m	struct:Elf32_Ehdr	file:
e_version	process.c	/^    Elf32_Word    e_version;$/;"	m	struct:Elf32_Ehdr	file:
eax	tss.c	/^    uint32_t eax, ecx, edx, ebx;$/;"	m	struct:tss	file:
ebp	tss.c	/^    uint32_t esp, ebp, esi, edi;$/;"	m	struct:tss	file:
ebx	tss.c	/^    uint32_t eax, ecx, edx, ebx;$/;"	m	struct:tss	file:
ecx	tss.c	/^    uint32_t eax, ecx, edx, ebx;$/;"	m	struct:tss	file:
edi	tss.c	/^    uint32_t esp, ebp, esi, edi;$/;"	m	struct:tss	file:
edx	tss.c	/^    uint32_t eax, ecx, edx, ebx;$/;"	m	struct:tss	file:
eflags	tss.c	/^    uint32_t eflags;$/;"	m	struct:tss	file:
eip	tss.c	/^    void (*eip) (void);$/;"	m	struct:tss	file:
es	tss.c	/^    uint16_t es, :16;$/;"	m	struct:tss	file:
esi	tss.c	/^    uint32_t esp, ebp, esi, edi;$/;"	m	struct:tss	file:
esp	tss.c	/^    uint32_t esp, ebp, esi, edi;$/;"	m	struct:tss	file:
esp0	tss.c	/^    void *esp0;                         \/* Ring 0 stack virtual address. *\/$/;"	m	struct:tss	file:
esp1	tss.c	/^    void *esp1;$/;"	m	struct:tss	file:
esp2	tss.c	/^    void *esp2;$/;"	m	struct:tss	file:
exception_init	exception.c	/^exception_init (void) $/;"	f
exception_print_stats	exception.c	/^exception_print_stats (void) $/;"	f
exec	syscall.c	/^pid_t exec(const char *cmd_line) \/\/ SYS_EXEC num = 2 - syscall 1$/;"	f
exit	syscall.c	/^void exit (int status) \/\/ SYS_EXIT num = 1 - syscall 1 $/;"	f
file	syscall.h	/^struct file$/;"	s
filesize	syscall.c	/^int filesize (int fd)$/;"	f
filesys_SRC	build/Makefile	/^filesys_SRC  = filesys\/filesys.c	# Filesystem core.$/;"	m
fs	tss.c	/^    uint16_t fs, :16;$/;"	m	struct:tss	file:
gdt	gdt.c	/^static uint64_t gdt[SEL_CNT];$/;"	v	file:
gdt_init	gdt.c	/^gdt_init (void)$/;"	f
gs	tss.c	/^    uint16_t gs, :16;$/;"	m	struct:tss	file:
halt	syscall.c	/^void halt (void) \/\/ SYS_HALT num = 0 - syscall 0 $/;"	f
indooe	syscall.h	/^	struct inode *indooe;$/;"	m	struct:file	typeref:struct:file::inode
install_page	process.c	/^install_page (void *upage, void *kpage, bool writable)$/;"	f	file:
invalidate_pagedir	pagedir.c	/^invalidate_pagedir (uint32_t *pd) $/;"	f	file:
kernel_SRC	build/Makefile	/^lib\/kernel_SRC  = lib\/kernel\/debug.c	# Debug helpers.$/;"	m
kill	exception.c	/^kill (struct intr_frame *f) $/;"	f	file:
ldt	tss.c	/^    uint16_t ldt, :16;$/;"	m	struct:tss	file:
lib_SRC	build/Makefile	/^lib_SRC  = lib\/debug.c			# Debug helpers.$/;"	m
load	process.c	/^load (const char *file_name, void (**eip) (void), void **esp) $/;"	f
load_segment	process.c	/^load_segment (struct file *file, off_t ofs, uint8_t *upage,$/;"	f	file:
lookup_page	pagedir.c	/^lookup_page (uint32_t *pd, const void *vaddr, bool create)$/;"	f	file:
make_code_desc	gdt.c	/^make_code_desc (int dpl)$/;"	f	file:
make_data_desc	gdt.c	/^make_data_desc (int dpl)$/;"	f	file:
make_gdtr_operand	gdt.c	/^make_gdtr_operand (uint16_t limit, void *base)$/;"	f	file:
make_seg_desc	gdt.c	/^make_seg_desc (uint32_t base,$/;"	f	file:
make_tss_desc	gdt.c	/^make_tss_desc (void *laddr)$/;"	f	file:
open	syscall.c	/^int open ( const char *file)$/;"	f
p_align	process.c	/^    Elf32_Word p_align;$/;"	m	struct:Elf32_Phdr	file:
p_filesz	process.c	/^    Elf32_Word p_filesz;$/;"	m	struct:Elf32_Phdr	file:
p_flags	process.c	/^    Elf32_Word p_flags;$/;"	m	struct:Elf32_Phdr	file:
p_memsz	process.c	/^    Elf32_Word p_memsz;$/;"	m	struct:Elf32_Phdr	file:
p_offset	process.c	/^    Elf32_Off  p_offset;$/;"	m	struct:Elf32_Phdr	file:
p_paddr	process.c	/^    Elf32_Addr p_paddr;$/;"	m	struct:Elf32_Phdr	file:
p_type	process.c	/^    Elf32_Word p_type;$/;"	m	struct:Elf32_Phdr	file:
p_vaddr	process.c	/^    Elf32_Addr p_vaddr;$/;"	m	struct:Elf32_Phdr	file:
page_fault	exception.c	/^page_fault (struct intr_frame *f) $/;"	f	file:
page_fault_cnt	exception.c	/^static long long page_fault_cnt;$/;"	v	file:
pagedir_activate	pagedir.c	/^pagedir_activate (uint32_t *pd) $/;"	f
pagedir_clear_page	pagedir.c	/^pagedir_clear_page (uint32_t *pd, void *upage) $/;"	f
pagedir_create	pagedir.c	/^pagedir_create (void) $/;"	f
pagedir_destroy	pagedir.c	/^pagedir_destroy (uint32_t *pd) $/;"	f
pagedir_get_page	pagedir.c	/^pagedir_get_page (uint32_t *pd, const void *uaddr) $/;"	f
pagedir_is_accessed	pagedir.c	/^pagedir_is_accessed (uint32_t *pd, const void *vpage) $/;"	f
pagedir_is_dirty	pagedir.c	/^pagedir_is_dirty (uint32_t *pd, const void *vpage) $/;"	f
pagedir_set_accessed	pagedir.c	/^pagedir_set_accessed (uint32_t *pd, const void *vpage, bool accessed) $/;"	f
pagedir_set_dirty	pagedir.c	/^pagedir_set_dirty (uint32_t *pd, const void *vpage, bool dirty) $/;"	f
pagedir_set_page	pagedir.c	/^pagedir_set_page (uint32_t *pd, void *upage, void *kpage, bool writable)$/;"	f
pib	syscall.c	/^int pib(int n)$/;"	f
pos	syscall.h	/^	off_t pos;$/;"	m	struct:file
process_activate	process.c	/^process_activate (void)$/;"	f
process_execute	process.c	/^process_execute (const char *file_name) $/;"	f
process_exit	process.c	/^process_exit (void)$/;"	f
process_wait	process.c	/^process_wait (tid_t child_tid ) $/;"	f
read	syscall.c	/^int read (int fd, void *buffer, unsigned size) \/\/ SYS_READ num = 8 - syscall 3$/;"	f
remove	syscall.c	/^bool remove ( const char *file)$/;"	f
seek	syscall.c	/^void seek(int fd, unsigned position)$/;"	f
seg_class	gdt.c	/^enum seg_class$/;"	g	file:
seg_granularity	gdt.c	/^enum seg_granularity$/;"	g	file:
setup_stack	process.c	/^setup_stack (void **esp) $/;"	f	file:
sofi	syscall.c	/^int sofi(int a,int b, int c,int d)$/;"	f
ss	tss.c	/^    uint16_t ss, :16;$/;"	m	struct:tss	file:
ss0	tss.c	/^    uint16_t ss0, :16;                  \/* Ring 0 stack segment selector. *\/$/;"	m	struct:tss	file:
ss1	tss.c	/^    uint16_t ss1, :16;$/;"	m	struct:tss	file:
ss2	tss.c	/^    uint16_t ss2, :16;$/;"	m	struct:tss	file:
start_process	process.c	/^start_process (void *file_name_)$/;"	f	file:
syscall_handler	syscall.c	/^syscall_handler (struct intr_frame *f) $/;"	f	file:
syscall_init	syscall.c	/^syscall_init (void) $/;"	f
tell	syscall.c	/^unsigned tell(int fd)$/;"	f
threads_SRC	build/Makefile	/^threads_SRC  = threads\/start.S		# Startup code.$/;"	m
trace	tss.c	/^    uint16_t trace, bitmap;$/;"	m	struct:tss	file:
tss	tss.c	/^static struct tss *tss;$/;"	v	typeref:struct:tss	file:
tss	tss.c	/^struct tss$/;"	s	file:
tss_get_	tss.c	/^tss_get_ (void) $/;"	f
tss_init	tss.c	/^tss_init (void) $/;"	f
tss_update	tss.c	/^tss_update (void) $/;"	f
userprog_SRC	build/Makefile	/^userprog_SRC  = userprog\/process.c	# Process loading.$/;"	m
validate_segment	process.c	/^validate_segment (const struct Elf32_Phdr *phdr, struct file *file) $/;"	f	file:
wait	syscall.c	/^int wait (pid_t pid) \/\/ SYS_WAIT num = 3 - syscall 1$/;"	f
write	syscall.c	/^int write (int fd, const void *buffer, unsigned size) \/\/ SYS_WRITE num = 9 - syscall 3$/;"	f
